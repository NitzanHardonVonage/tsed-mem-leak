"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const Fs = require("fs");
const OpenApiEndpointBuilder_1 = require("../class/OpenApiEndpointBuilder");
const utils_1 = require("../utils");
let SwaggerService = class SwaggerService {
    constructor(injectorService, routeService, configuration) {
        this.injectorService = injectorService;
        this.routeService = routeService;
        this.configuration = configuration;
        /**
         *
         * @param {ISwaggerSettings} conf
         * @returns {(targetName: string, methodName: string) => (any | string)}
         */
        this.createOperationIdFormatter = (conf) => {
            const OPERATION_IDS = {};
            return (targetName, methodName) => {
                const { operationIdFormat = "%c.%m" } = conf || {};
                const operationId = operationIdFormat.replace(/%c/, targetName).replace(/%m/, methodName);
                const operationKey = targetName + methodName;
                if (OPERATION_IDS[operationKey] === undefined) {
                    OPERATION_IDS[operationKey] = 0;
                    return operationId;
                }
                const id = OPERATION_IDS[operationKey] + 1;
                OPERATION_IDS[operationKey] = id;
                return operationId + "_" + id;
            };
        };
    }
    /**
     *
     * @returns {Spec}
     */
    getOpenAPISpec(conf) {
        const defaultSpec = this.getDefaultSpec(conf);
        const paths = {};
        const definitions = {};
        const doc = conf.doc;
        let tags = [];
        const getOperationId = this.createOperationIdFormatter(conf);
        this.routeService.routes.forEach(({ provider, route }) => {
            const hidden = provider.store.get("hidden");
            const docs = provider.store.get("docs") || [];
            if ((!doc && !hidden) || (doc && docs.indexOf(doc) > -1)) {
                tags = tags.concat(this.buildRoutes(paths, definitions, provider, route, getOperationId));
            }
        });
        tags = tags.sort((a, b) => (a.name < b.name ? -1 : 1));
        return core_1.deepExtends(defaultSpec, {
            tags,
            paths,
            definitions
        }, utils_1.getReducers());
    }
    /**
     * Return the global api information.
     * @returns {Info}
     */
    getDefaultSpec(conf) {
        const { version } = this.configuration;
        const spec = conf.spec ||
            {
                info: {},
                securityDefinitions: {}
            };
        const specPath = conf.specPath;
        let specPathContent = {};
        if (specPath) {
            specPathContent = this.readSpecPath(specPath);
        }
        /* istanbul ignore next */
        const { title = "Api documentation", description = "", version: versionInfo, termsOfService = "", contact, license } = spec.info || {};
        return core_1.deepExtends(Object.assign(Object.assign({ swagger: "2.0" }, spec), { info: {
                version: versionInfo || version,
                title,
                description,
                termsOfService,
                contact,
                license
            }, consumes: this.configuration.acceptMimes.concat(spec.consumes || []), produces: spec.produces || ["application/json"], securityDefinitions: spec.securityDefinitions || {} }), specPathContent, utils_1.getReducers());
    }
    readSpecPath(path) {
        path = this.configuration.resolve(path);
        if (Fs.existsSync(path)) {
            const json = Fs.readFileSync(path, { encoding: "utf8" });
            /* istanbul ignore else */
            if (json !== "") {
                return JSON.parse(json);
            }
        }
        return {};
    }
    /**
     *
     * @param paths
     * @param definitions
     * @param ctrl
     * @param endpointUrl
     * @param getOperationId
     */
    buildRoutes(paths, definitions, ctrl, endpointUrl, getOperationId) {
        let tags = [];
        ctrl.children
            .map(ctrl => this.injectorService.getProvider(ctrl))
            .forEach((provider) => {
            if (!provider.store.get("hidden")) {
                tags = tags.concat(this.buildRoutes(paths, definitions, provider, `${endpointUrl}${provider.path}`, getOperationId));
            }
        });
        ctrl.endpoints.forEach((endpoint) => {
            if (endpoint.store.get("hidden")) {
                return;
            }
            endpoint.pathsMethods.forEach(pathMethod => {
                /* istanbul ignore else */
                if (!!pathMethod.method) {
                    const builder = new OpenApiEndpointBuilder_1.OpenApiEndpointBuilder(endpoint, endpointUrl, pathMethod, getOperationId).build();
                    core_1.deepExtends(paths, builder.paths);
                    core_1.deepExtends(definitions, builder.definitions);
                }
            });
        });
        return ctrl.endpoints.length ? tags.concat(this.buildTags(ctrl)) : tags;
    }
    /**
     *
     * @param ctrl
     */
    buildTags(ctrl) {
        const clazz = ctrl.useClass;
        const ctrlStore = core_1.Store.from(clazz);
        return Object.assign({
            name: ctrlStore.get("name") || core_1.nameOf(clazz),
            description: ctrlStore.get("description")
        }, ctrlStore.get("tag") || {});
    }
};
SwaggerService = tslib_1.__decorate([
    common_1.Service(),
    tslib_1.__param(2, common_1.Configuration()),
    tslib_1.__metadata("design:paramtypes", [common_1.InjectorService,
        common_1.RouteService, Object])
], SwaggerService);
exports.SwaggerService = SwaggerService;
//# sourceMappingURL=SwaggerService.js.map