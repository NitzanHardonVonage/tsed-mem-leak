"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
function getVariable(subpath) {
    const splited = subpath.split(".");
    const name = splited.splice(0, 1)[0];
    return {
        name,
        postfix: splited.length ? `.${splited.join(".")}` : ""
    };
}
function parseSwaggerPath(base, path = "") {
    if (path instanceof RegExp) {
        path = path
            .toString()
            .replace(/^\//, "")
            .replace(/\/$/, "")
            .replace(/\\/, "");
    }
    const params = [];
    const paths = [];
    let isOptional = false;
    let current = "";
    `${base}${path}`
        .replace(/\((.*)\)/gi, "")
        .split("/")
        .filter(o => !!o)
        .map(key => {
        const subpath = key.replace(":", "").replace("?", "");
        if (key.includes(":")) {
            const optional = key.includes("?");
            // Append previous config
            if (optional && !isOptional) {
                isOptional = true;
                paths.push({
                    path: current,
                    pathParams: [].concat(params)
                });
            }
            const { name, postfix } = getVariable(subpath);
            current += `/{${name}}${postfix}`;
            params.push({
                in: "path",
                name,
                type: "string",
                required: true
            });
            if (optional && isOptional) {
                paths.push({
                    path: current,
                    pathParams: [].concat(params)
                });
            }
        }
        else {
            current += `/${key}`;
        }
    });
    return paths.length
        ? paths
        : [
            {
                path: current,
                pathParams: [].concat(params)
            }
        ];
}
exports.parseSwaggerPath = parseSwaggerPath;
/**
 *
 * @param type
 * @returns {string | string[]}
 */
function swaggerType(type) {
    return common_1.JsonSchema.getJsonType(type);
}
exports.swaggerType = swaggerType;
/**
 * Filter the null type, unsupported by swagger and apply the right type on schema.
 * @param schema
 * @param type
 */
function swaggerApplyType(schema, type) {
    const types = []
        .concat(swaggerType(type))
        .filter(type => {
        if (type === "null") {
            schema.nullable = true;
            return false;
        }
        return type;
    })
        .map(type => String(type));
    if (types.length === 1) {
        schema.type = types[0];
    }
    else {
        delete schema.type;
        schema.oneOf = types.map(type => ({ type }));
    }
    return schema;
}
exports.swaggerApplyType = swaggerApplyType;
/**
 *
 * @returns {{[p: string]: (collection: any[], value: any) => any}}
 */
function getReducers() {
    const defaultReducer = (collection, value) => {
        if (collection.indexOf(value) === -1) {
            collection.push(value);
        }
        return collection;
    };
    return {
        default: defaultReducer,
        security: (collection, value) => {
            const current = collection.find((current) => {
                return Object.keys(value).find(key => !!current[key]);
            });
            if (current) {
                core_1.deepExtends(current, value, { default: defaultReducer });
            }
            else {
                collection.push(value);
            }
            return collection;
        },
        parameters: (collection, value) => {
            const current = collection.find(current => current.in === value.in && current.name === value.name);
            if (current) {
                core_1.deepExtends(current, value);
            }
            else {
                collection.push(value);
            }
            return collection;
        },
        oneOf: (collection, value) => {
            const current = collection.find(current => current.type === value.type);
            if (current) {
                core_1.deepExtends(current, value);
            }
            else {
                collection.push(value);
            }
            return collection;
        }
    };
}
exports.getReducers = getReducers;
//# sourceMappingURL=index.js.map