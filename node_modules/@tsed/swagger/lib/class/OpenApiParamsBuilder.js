"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const utils_1 = require("../utils");
const OpenApiModelSchemaBuilder_1 = require("./OpenApiModelSchemaBuilder");
class OpenApiParamsBuilder extends OpenApiModelSchemaBuilder_1.OpenApiModelSchemaBuilder {
    constructor(target, methodClassName, pathParameters = []) {
        super(target);
        this.pathParameters = pathParameters;
        this._parameters = [];
        this.hasBody = false;
        this.hasFormData = false;
        this.name = "";
        this.name = `${core_1.nameOf(target)}${methodClassName.charAt(0).toUpperCase() + methodClassName.slice(1)}`;
        this.injectedParams = common_1.ParamRegistry.getParams(target, methodClassName).filter(param => {
            if (param.paramType === common_1.ParamTypes.BODY) {
                this.hasBody = true;
            }
            if (param.paramType === common_1.ParamTypes.FORM_DATA) {
                this.hasFormData = true;
            }
            return !param.store.get("hidden");
        });
        const fromMethod = core_1.Store.fromMethod(target, methodClassName);
        const operation = fromMethod.get("operation");
        if (operation && operation.consumes && operation.consumes.indexOf("application/x-www-form-urlencoded") > -1) {
            this.hasFormData = true;
        }
    }
    get parameters() {
        return this._parameters;
    }
    /**
     *
     * @returns {this}
     */
    build() {
        this._parameters = [];
        this._parameters = this._parameters.concat(this.getInHeaders(), this.getInPathParams(), this.getInQueryParams());
        if (this.hasFormData) {
            this._parameters = this._parameters.concat(this.getInFormData());
        }
        else if (this.hasBody) {
            this._parameters = this._parameters.concat(this.getInBodyParam());
        }
        return this;
    }
    /**
     *
     * @param param
     * @returns {Schema}
     */
    createSchemaFromBodyParam(param) {
        let builder;
        const { currentProperty, schema } = this.createSchemaFromExpression(param);
        if (param.isClass) {
            builder = new OpenApiModelSchemaBuilder_1.OpenApiModelSchemaBuilder(param.type);
            builder.build();
            core_1.deepExtends(this._definitions, builder.definitions);
            core_1.deepExtends(this._responses, builder.responses);
        }
        Object.assign(currentProperty, super.createSchema({
            schema: param.store.get("schema"),
            type: param.type,
            collectionType: param.collectionType
        }));
        return schema;
    }
    /**
     *
     * @param {ParamMetadata} model
     * @returns {Schema}
     */
    createSchemaFromQueryParam(model) {
        const type = utils_1.swaggerType(model.type);
        if (model.isCollection) {
            if (model.isArray) {
                return {
                    type: "array",
                    collectionFormat: "multi",
                    items: {
                        type
                    }
                };
            }
            return {
                type: "object",
                additionalProperties: {
                    type
                }
            };
        }
        return {
            type
        };
    }
    /**
     *
     * @returns {HeaderParameter[]}
     */
    getInHeaders() {
        return this.injectedParams
            .filter((param) => param.paramType === common_1.ParamTypes.HEADER)
            .map(param => {
            return Object.assign({}, param.store.get("baseParameter"), {
                in: "header",
                name: param.expression,
                type: utils_1.swaggerType(param.type),
                required: param.required
            });
        });
    }
    /**
     *
     * @returns {any[]}
     */
    getInFormData() {
        return this.injectedParams
            .filter((param) => param.paramType === common_1.ParamTypes.BODY || param.paramType === common_1.ParamTypes.FORM_DATA)
            .map(param => {
            const name = (param.expression || "").replace(".0", "");
            const type = param.paramType === common_1.ParamTypes.FORM_DATA ? "file" : utils_1.swaggerType(param.paramType);
            return Object.assign({}, param.store.get("baseParameter"), {
                in: "formData",
                name,
                required: param.required,
                type
            });
        });
    }
    /**
     *
     * @returns {ParamMetadata | undefined}
     */
    getInBodyParam() {
        const params = this.injectedParams.filter((param) => param.paramType === common_1.ParamTypes.BODY);
        const param = params.find((param) => !param.expression);
        if (param) {
            const builder = new OpenApiModelSchemaBuilder_1.OpenApiModelSchemaBuilder(param.type);
            builder.build();
            core_1.deepExtends(this._responses, builder.responses);
            this._definitions = Object.assign(Object.assign({}, this._definitions), builder.definitions);
            if (param.required) {
                this.addResponse400();
            }
            return Object.assign({ description: "" }, param.store.get("baseParameter"), {
                in: "body",
                name: "body",
                required: !!param.required,
                schema: this.createSchema({
                    schema: param.store.get("schema"),
                    type: param.type,
                    collectionType: param.collectionType
                })
            });
        }
        let required = false;
        const model = `${this.name}Payload`;
        const schema = params.reduce((acc, param) => {
            core_1.deepExtends(acc, this.createSchemaFromBodyParam(param));
            if (param.required) {
                this.addResponse400();
                required = true;
            }
            return acc;
        }, {});
        this._definitions[model] = schema;
        return {
            in: "body",
            name: "body",
            required,
            description: "",
            schema: {
                $ref: `#/definitions/${model}`
            }
        };
    }
    /**
     *
     * @returns {PathParameter[]}
     */
    getInPathParams() {
        const inPathParams = [];
        const pathParams = new Map();
        this.injectedParams.forEach((param) => {
            if (param.paramType === common_1.ParamTypes.PATH) {
                pathParams.set(param.expression, param);
            }
        });
        this.pathParameters.forEach(pathParam => {
            if (pathParams.has(pathParam.name)) {
                const param = pathParams.get(pathParam.name);
                pathParam = Object.assign({}, pathParam, param.store.get("baseParameter") || {}, {
                    type: utils_1.swaggerType(param.type)
                });
            }
            inPathParams.push(Object.assign(pathParam, { required: true }));
        });
        return inPathParams;
    }
    /**
     *
     * @returns {HeaderParameter[]}
     */
    getInQueryParams() {
        return this.injectedParams
            .filter((param) => param.paramType === common_1.ParamTypes.QUERY)
            .map(param => {
            if (param.required) {
                this.addResponse400();
            }
            return Object.assign({}, param.store.get("baseParameter"), {
                in: "query",
                name: param.expression,
                required: !!param.required
            }, this.createSchemaFromQueryParam(param));
        });
    }
    /**
     * Create Properties schema from an expression.
     * @param param
     */
    createSchemaFromExpression(param) {
        const schema = {};
        let current = schema;
        const expression = param.expression || "";
        if (!!expression) {
            const keys = expression.split(".");
            keys.forEach(key => {
                current.type = "object";
                current.properties = current.properties || {};
                current.properties[key] = {};
                if (param.required) {
                    current.required = [key];
                }
                current = current.properties[key];
            });
        }
        return { currentProperty: current, schema };
    }
    addResponse400() {
        this._responses[400] = { description: "Missing required parameter" };
    }
}
exports.OpenApiParamsBuilder = OpenApiParamsBuilder;
//# sourceMappingURL=OpenApiParamsBuilder.js.map