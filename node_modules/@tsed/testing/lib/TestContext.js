"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
class TestContext {
    static get injector() {
        if (this._injector) {
            return this._injector;
        }
        /* istanbul ignore next */
        throw new Error("TestContext.injector is not initialized. Use TestContext.create(): Promise before TestContext.invoke() or TestContext.injector.\n" +
            "Example:\n" +
            "before(async () => {\n" +
            "   await TestContext.create()\n" +
            "   await TestContext.invoke(MyService, [])\n" +
            "})");
    }
    static create(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            TestContext._injector = TestContext.createInjector(options);
            yield common_1.loadInjector(TestContext._injector);
        });
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(options = {}) {
        const injector = common_1.createInjector(options);
        common_1.createExpressApplication(injector);
        common_1.createHttpServer(injector);
        common_1.createHttpsServer(injector);
        injector.settings.env = core_1.Env.TEST;
        return injector;
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param options
     * @returns {Promise<void>}
     */
    static bootstrap(mod, options = {}) {
        return function before() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const instance = yield common_1.ServerLoader.bootstrap(mod, Object.assign({ logger: {
                        level: "off"
                    } }, options));
                yield instance.callHook("$beforeListen");
                yield instance.callHook("$afterListen");
                yield instance.ready();
                // used by inject method
                TestContext._injector = instance.injector;
            });
        };
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static reset() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (TestContext._injector) {
                yield TestContext._injector.destroy();
                TestContext._injector = null;
            }
        });
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!TestContext._injector) {
                yield TestContext.create();
            }
            const injector = TestContext.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : yield injector.invoke(target));
            }
            return yield func(...deps);
        });
    }
    static invoke(target, providers) {
        const locals = new common_1.LocalsContainer();
        providers.forEach(p => {
            locals.set(p.provide, p.use);
        });
        const instance = TestContext.injector.invoke(target, locals, { rebuild: true });
        if (instance && instance.$onInit) {
            // await instance.$onInit();
            const result = instance.$onInit();
            if (result instanceof Promise) {
                return result.then(() => instance);
            }
        }
        return instance;
    }
}
exports.TestContext = TestContext;
TestContext._injector = null;
//# sourceMappingURL=TestContext.js.map