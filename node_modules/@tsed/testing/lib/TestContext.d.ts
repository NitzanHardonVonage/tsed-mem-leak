import { IDIConfigurationOptions, ServerLoader, TokenProvider } from "@tsed/common";
import { Type } from "@tsed/core";
import { InjectorService } from "@tsed/di";
export declare class TestContext {
    private static _injector;
    static get injector(): InjectorService;
    static create(options?: Partial<IDIConfigurationOptions>): Promise<void>;
    /**
     * Create a new injector with the right default services
     */
    static createInjector(options?: any): InjectorService;
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param options
     * @returns {Promise<void>}
     */
    static bootstrap(mod: Type<ServerLoader>, options?: Partial<IDIConfigurationOptions>): () => Promise<void>;
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static reset(): Promise<void>;
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject<T>(targets: any[], func: (...args: any[]) => Promise<T> | T): () => Promise<T>;
    static invoke<T = any>(target: TokenProvider, providers: {
        provide: any | symbol;
        use: any;
    }[]): T | Promise<any>;
}
