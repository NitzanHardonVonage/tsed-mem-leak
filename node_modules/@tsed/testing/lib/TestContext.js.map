{"version":3,"file":"TestContext.js","sourceRoot":"","sources":["../src/TestContext.ts"],"names":[],"mappings":";;;AAAA,yCAWsB;AACtB,qCAAqC;AAGrC,MAAa,WAAW;IAGtB,MAAM,KAAK,QAAQ;QACjB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,OAAO,IAAI,CAAC,SAAU,CAAC;SACxB;QAED,0BAA0B;QAC1B,MAAM,IAAI,KAAK,CACb,mIAAmI;YACjI,YAAY;YACZ,wBAAwB;YACxB,iCAAiC;YACjC,8CAA8C;YAC9C,IAAI,CACP,CAAC;IACJ,CAAC;IAED,MAAM,CAAO,MAAM,CAAC,UAA4C,EAAE;;YAChE,WAAW,CAAC,SAAS,GAAG,WAAW,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;YAE5D,MAAM,qBAAY,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;QAC5C,CAAC;KAAA;IAED;;OAEG;IACH,MAAM,CAAC,cAAc,CAAC,UAAe,EAAE;QACrC,MAAM,QAAQ,GAAG,uBAAc,CAAC,OAAO,CAAC,CAAC;QACzC,iCAAwB,CAAC,QAAQ,CAAC,CAAC;QACnC,yBAAgB,CAAC,QAAQ,CAAC,CAAC;QAC3B,0BAAiB,CAAC,QAAQ,CAAC,CAAC;QAE5B,QAAQ,CAAC,QAAQ,CAAC,GAAG,GAAG,UAAG,CAAC,IAAI,CAAC;QAEjC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,SAAS,CAAC,GAAuB,EAAE,UAA4C,EAAE;QACtF,OAAO,SAAe,MAAM;;gBAC1B,MAAM,QAAQ,GAAG,MAAM,qBAAY,CAAC,SAAS,CAAC,GAAG,kBAC/C,MAAM,EAAE;wBACN,KAAK,EAAE,KAAK;qBACb,IACE,OAAO,EACV,CAAC;gBAEH,MAAM,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;gBACzC,MAAM,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;gBACxC,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAC;gBAEvB,wBAAwB;gBACxB,WAAW,CAAC,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC;YAC5C,CAAC;SAAA,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,MAAM,CAAO,KAAK;;YAChB,IAAI,WAAW,CAAC,SAAS,EAAE;gBACzB,MAAM,WAAW,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;gBACtC,WAAW,CAAC,SAAS,GAAG,IAAI,CAAC;aAC9B;QACH,CAAC;KAAA;IAED;;;;;;;;;;OAUG;IACH,MAAM,CAAC,MAAM,CAAI,OAAc,EAAE,IAAwC;QACvE,OAAO,GAAqB,EAAE;YAC5B,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE;gBAC1B,MAAM,WAAW,CAAC,MAAM,EAAE,CAAC;aAC5B;YAED,MAAM,QAAQ,GAAoB,WAAW,CAAC,QAAQ,CAAC;YACvD,MAAM,IAAI,GAAG,EAAE,CAAC;YAEhB,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;aACxF;YAED,OAAO,MAAM,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAA,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,MAAM,CAAU,MAAqB,EAAE,SAA8C;QAC1F,MAAM,MAAM,GAAG,IAAI,wBAAe,EAAE,CAAC;QACrC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACpB,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAW,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAEtF,IAAI,QAAQ,IAAI,QAAQ,CAAC,OAAO,EAAE;YAChC,4BAA4B;YAC5B,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;YAClC,IAAI,MAAM,YAAY,OAAO,EAAE;gBAC7B,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC;aACpC;SACF;QAED,OAAO,QAAe,CAAC;IACzB,CAAC;;AAvHH,kCAwHC;AAvHgB,qBAAS,GAA2B,IAAI,CAAC","sourcesContent":["import {\n  createExpressApplication,\n  createHttpServer,\n  createHttpsServer,\n  createInjector,\n  IDIConfigurationOptions,\n  loadInjector,\n  LocalsContainer,\n  OnInit,\n  ServerLoader,\n  TokenProvider\n} from \"@tsed/common\";\nimport {Env, Type} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\n\nexport class TestContext {\n  private static _injector: InjectorService | null = null;\n\n  static get injector(): InjectorService {\n    if (this._injector) {\n      return this._injector!;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\n      \"TestContext.injector is not initialized. Use TestContext.create(): Promise before TestContext.invoke() or TestContext.injector.\\n\" +\n        \"Example:\\n\" +\n        \"before(async () => {\\n\" +\n        \"   await TestContext.create()\\n\" +\n        \"   await TestContext.invoke(MyService, [])\\n\" +\n        \"})\"\n    );\n  }\n\n  static async create(options: Partial<IDIConfigurationOptions> = {}) {\n    TestContext._injector = TestContext.createInjector(options);\n\n    await loadInjector(TestContext._injector);\n  }\n\n  /**\n   * Create a new injector with the right default services\n   */\n  static createInjector(options: any = {}): InjectorService {\n    const injector = createInjector(options);\n    createExpressApplication(injector);\n    createHttpServer(injector);\n    createHttpsServer(injector);\n\n    injector.settings.env = Env.TEST;\n\n    return injector;\n  }\n\n  /**\n   * Load the server silently without listening port and configure it on test profile.\n   * @decorator\n   * @param mod\n   * @param options\n   * @returns {Promise<void>}\n   */\n  static bootstrap(mod: Type<ServerLoader>, options: Partial<IDIConfigurationOptions> = {}): () => Promise<void> {\n    return async function before(): Promise<void> {\n      const instance = await ServerLoader.bootstrap(mod, {\n        logger: {\n          level: \"off\"\n        },\n        ...options\n      });\n\n      await instance.callHook(\"$beforeListen\");\n      await instance.callHook(\"$afterListen\");\n      await instance.ready();\n\n      // used by inject method\n      TestContext._injector = instance.injector;\n    };\n  }\n\n  /**\n   * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.\n   */\n  static async reset() {\n    if (TestContext._injector) {\n      await TestContext._injector.destroy();\n      TestContext._injector = null;\n    }\n  }\n\n  /**\n   * It injects services into the test function where you can alter, spy on, and manipulate them.\n   *\n   * The inject function has two parameters\n   *\n   * * an array of Service dependency injection tokens,\n   * * a test function whose parameters correspond exactly to each item in the injection token array.\n   *\n   * @param targets\n   * @param func\n   */\n  static inject<T>(targets: any[], func: (...args: any[]) => Promise<T> | T): () => Promise<T> {\n    return async (): Promise<T> => {\n      if (!TestContext._injector) {\n        await TestContext.create();\n      }\n\n      const injector: InjectorService = TestContext.injector;\n      const deps = [];\n\n      for (const target of targets) {\n        deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));\n      }\n\n      return await func(...deps);\n    };\n  }\n\n  static invoke<T = any>(target: TokenProvider, providers: {provide: any | symbol; use: any}[]): T | Promise<any> {\n    const locals = new LocalsContainer();\n    providers.forEach(p => {\n      locals.set(p.provide, p.use);\n    });\n\n    const instance: OnInit = TestContext.injector.invoke(target, locals, {rebuild: true});\n\n    if (instance && instance.$onInit) {\n      // await instance.$onInit();\n      const result = instance.$onInit();\n      if (result instanceof Promise) {\n        return result.then(() => instance);\n      }\n    }\n\n    return instance as any;\n  }\n}\n"]}